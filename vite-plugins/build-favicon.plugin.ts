import favicons, { FaviconFile, FaviconImage, FaviconResponse, FaviconStreamOptions } from 'favicons';
import fs from 'fs';
import { parseFragment } from 'parse5';
import path from 'path';
import type { PluginContext } from 'rollup';
import { HtmlTagDescriptor, PluginOption, ResolvedConfig } from 'vite';

const getDefaultFaviconConfig = (): Partial<FaviconStreamOptions> => {
  return {
    appName: 'Pisano',
    appDescription: 'Pisano is a suite of products that help you make feedback driven decisions.',
    dir: 'auto',
    lang: 'en-US',
    background: 'transparent',
    theme_color: '#0d7bff',
    display: 'standalone',
    orientation: 'any',
    scope: '/',
    start_url: '/',
    version: '1.0',
    pixel_art: false,
    loadManifestWithCredentials: false,
    icons: {
      android: true,
      appleIcon: true,
      appleStartup: true,
      favicons: true,
      windows: false,
      yandex: false,
    },
  };
};

export function BuildFaviconPlugin(logoPath: string) {
  let config: ResolvedConfig;

  const LOGO_PATH = path.resolve(logoPath);
  const faviconConfig = getDefaultFaviconConfig();
  const getFavicons = async () => {
    return favicons(LOGO_PATH, faviconConfig);
  };

  const tags: HtmlTagDescriptor[] = [];
  const assetIds: Map<string, string> = new Map();
  let faviconResponse: FaviconResponse;
  let manifestFileName: string;

  const emitAssets = (ctx: PluginContext, list: Array<FaviconFile | FaviconImage>) => {
    for (const { name, contents } of list) {
      const refId = ctx.emitFile({ type: 'asset', name, source: contents });
      assetIds.set(name, refId);
    }
  };

  return {
    name: 'vite:build-favicon',
    apply: 'build',
    enforce: 'pre',
    configResolved(resolvedConfig: ResolvedConfig) {
      config = resolvedConfig;
    },
    async buildStart(this: PluginContext) {
      this.addWatchFile(LOGO_PATH);
      faviconResponse = await getFavicons();

      emitAssets(this, faviconResponse.files);
      emitAssets(this, faviconResponse.images);
    },
    async generateBundle(this: PluginContext) {
      for (const tag of faviconResponse.html) {
        const node = parseFragment(tag).childNodes[0] as unknown as {
          nodeName: string;
          attrs: [{ name: string; value: string }];
        };
        // Don't add meta tags, it'll be added via HtmlMetaTagPlugin
        if (node.nodeName === 'meta') {
          continue;
        }

        const attrs = node.attrs.reduce((acc, { name, value }) => {
          const fileName = value.slice(1);

          if (name === 'href' && value.includes('webmanifest')) {
            const assetId = assetIds.get(fileName);
            if (assetId) {
              manifestFileName = this.getFileName(assetId);
            }
          }

          if (name === 'href' && assetIds.has(fileName)) {
            const assetId = assetIds.get(fileName);
            if (assetId) {
              acc[name] = `/${this.getFileName(assetId)}`;
            } else {
              acc[name] = value;
            }
          } else {
            acc[name] = value;
          }

          return acc;
        }, {});

        tags.push({
          tag: node.nodeName,
          injectTo: 'head-prepend',
          attrs,
        });
      }
    },
    transformIndexHtml() {
      return tags;
    },
    closeBundle() {
      const {
        root,
        build: { outDir },
      } = config;
      const outDirectory = path.posix.resolve(root, outDir);
      const assetsDirectory = path.posix.join(outDirectory, 'assets');
      if (!manifestFileName) {
        return;
      }
      const webmanifest = path.posix.join(outDirectory, manifestFileName);

      // Rewrite webmanifest icons array with new file names
      // It adds hash to file names while bundling, so we replace the previous icons array which generated by "favicons" library
      // dist/assets/manifest.[hash].webmanifest
      const icons = fs
        .readdirSync(assetsDirectory)
        .filter((name) => name.includes('android'))
        .map((name) => {
          // android-chrome-144x144-68a61585.png
          const splitted = name.split('.')[0].split('-');
          const sizes = splitted[splitted.length - 2];

          return {
            src: name,
            sizes,
            type: 'image/png',
            purpose: 'any',
          };
        });

      const content = fs.readFileSync(webmanifest).toString();
      const parsed = JSON.parse(content);
      const newContent = JSON.stringify({ ...parsed, icons }, null, 2);

      // public/favicon.ico is used only in local development
      fs.rmSync(path.posix.join(outDirectory, 'favicon.ico'));

      fs.writeFileSync(webmanifest, newContent);
    },
  } as PluginOption;
}
